package com.jonnyzzz.mplay.agent.runtime.impl

import com.jonnyzzz.mplay.agent.runtime.*
import java.io.File
import java.net.URL

/**
 * This class methods are executed directly from
 * the generated bytecode. This class defines the
 * interface
 */
open class MPlayMethodCallRecorderImpl(
    val recorder: MPlayRecorderImpl,
    val methodName: String,
    val methodDescriptor: String
) : MPlayValuesVisitor, MPlayExceptionVisitor, MPlayMethodResultRecorder, MPlayMethodCallRecorder {
    /**
     * Each of the `visit*` methods is used from the generated
     * bytecode to send and update every method arguments.
     * The default implementation returns the same value back,
     * but there are scenarios where it would make sense to
     * return a different value for a callback parameters
     */
    override fun visitBoolean(v: Boolean): Boolean = v.apply { println("${recorder.recordingClassName}#$methodName boolean $v") }
    override fun visitChar(v: Char): Char = v.apply { println("${recorder.recordingClassName}#$methodName char $v") }
    override fun visitByte(v: Byte): Byte = v.apply { println("${recorder.recordingClassName}#$methodName byte $v") }
    override fun visitShort(v: Short): Short = v.apply { println("${recorder.recordingClassName}#$methodName short $v") }
    override fun visitInt(v: Int): Int = v.apply { println("${recorder.recordingClassName}#$methodName int $v") }
    override fun visitLong(v: Long): Long = v.apply { println("${recorder.recordingClassName}#$methodName long $v") }
    override fun visitFloat(v: Float): Float = v.apply { println("${recorder.recordingClassName}#$methodName float $v") }
    override fun visitDouble(v: Double): Double = v.apply { println("${recorder.recordingClassName}#$methodName double $v") }
    override fun visitObject(v: Any?): Any? = v.apply { println("${recorder.recordingClassName}#$methodName object $v") }
    override fun visitException(v: Throwable): Throwable = v.apply { println("${recorder.recordingClassName}#$methodName exception $v") }

    /**
     * An additional callback to notify all method call parameters were reported
     */
    override fun visitParametersComplete() : MPlayMethodCallRecorderImpl {
        println("${recorder.recordingClassName}#$methodName parameters visited")
        return this
    }

    override fun commit() {
        println("${recorder.recordingClassName}#$methodName commitWithResult")
    }
}


data class MPlayRecorderImpl(
    val recordingClassName: String,
    val configClassName: String,
    val configClasspath: List<URL>,
) : MPlayRecorder {
    init {
        println("MPlayRecorder[$recordingClassName] created")
    }

    /**
     * Used the [InterceptMethodTask.methodName] and [InterceptMethodTask.jvmMethodDescriptor]
     */
    override fun onMethodEnter(methodName: String, jvmMethodDescriptor: String) : MPlayMethodCallRecorder {
        println("MPlayRecorder[$recordingClassName] on method: $methodName $jvmMethodDescriptor")
        return MPlayMethodCallRecorderImpl(this, methodName, jvmMethodDescriptor)
    }

    companion object {
        /**
         * This method is executed in bytecode
         */
        @JvmStatic
        fun getInstance(
            recordingClassName: String,
            configClassName: String,
            /**
             * classpath separated with [File.separator]
             */
            configClasspath: String,
        ): MPlayRecorder {
            //we may do caching here if needed
            return MPlayRecorderImpl(
                recordingClassName,
                configClassName,
                configClasspath.split(File.separator).map { File(it).toURI().toURL() })
        }
    }
}
