@file:Suppress("unused", "UNUSED_PARAMETER", "KDocUnresolvedReference")

package com.jonnyzzz.mplay.agent.runtime

import java.io.File
import java.net.URL

/**
 * This class methods are executed directly from
 * the generated bytecode. This class defines the
 * interface
 */
open class MPlayMethodCallRecorder(
    val recorder: MPlayRecorder,
    val methodName: String,
    val methodDescriptor: String
) {
    fun writeBoolean(b: Boolean) { println("${recorder.recordingClassName}#$methodName boolean $b") }
    fun writeChar(i: Char) { println("${recorder.recordingClassName}#$methodName char $i") }
    fun writeByte(b: Byte) { println("${recorder.recordingClassName}#$methodName byte $b") }
    fun writeShort(s: Short) { println("${recorder.recordingClassName}#$methodName short $s") }
    fun writeInt(i: Int) { println("${recorder.recordingClassName}#$methodName int $i") }
    fun writeLong(l: Long) { println("${recorder.recordingClassName}#$methodName long $l") }
    fun writeFloat(f: Float) { println("${recorder.recordingClassName}#$methodName float $f") }
    fun writeDouble(d: Double) { println("${recorder.recordingClassName}#$methodName double $d") }
    fun writeObject(o: Any?) { println("${recorder.recordingClassName}#$methodName object $o") }

    /**
     * Writes method completed successfully, assuming the
     * method result was send via the last call with a `write*` method.
     *
     * The write must not be called if the method result is [Void]
     */
    fun commitWithResult() {
        println("commitWithResult")
    }

    /**
     * Writes method completed with an exception, sending the
     * exception as the method parameter
     */
    fun commitWithException(exception: Throwable) {
        println("commitWithException")
    }
}

data class MPlayRecorder(
    val recordingClassName: String,
    val configClassName: String,
    val configClasspath: List<URL>,
) {
    init {
        println("MPlayRecorder[$recordingClassName] created")
    }

    /**
     * Used the [InterceptMethodTask.methodName] and [InterceptMethodTask.jvmMethodDescriptor]
     */
    fun onMethodEnter(methodName: String, jvmMethodDescriptor: String) : MPlayMethodCallRecorder {
        println("MPlayRecorder[$recordingClassName] on method: $methodName $jvmMethodDescriptor")
        return MPlayMethodCallRecorder(this, methodName, jvmMethodDescriptor)
    }

    companion object {
        /**
         * This method is executed in bytecode
         */
        @JvmStatic
        fun getInstance(
            recordingClassName: String,
            configClassName: String,
            /**
             * classpath separated with [File.separator]
             */
            configClasspath: String,
        ): MPlayRecorder {
            //we may do caching here if needed
            return MPlayRecorder(
                recordingClassName,
                configClassName,
                configClasspath.split(File.separator).map { File(it).toURI().toURL() })
        }
    }
}
