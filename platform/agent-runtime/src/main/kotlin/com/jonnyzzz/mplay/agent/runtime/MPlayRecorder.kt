@file:Suppress("unused", "UNUSED_PARAMETER", "KDocUnresolvedReference")

package com.jonnyzzz.mplay.agent.runtime

import java.io.File
import java.net.URL

/**
 * This class methods are executed directly from
 * the generated bytecode. This class defines the
 * interface
 */
open class MPlayMethodCallRecorder(
    val recorder: MPlayRecorder,
    val methodName: String,
    val methodDescriptor: String
) {
    /**
     * Each of the `visit*` methods is used from the generated
     * bytecode to send and update every method arguments.
     * The default implementation returns the same value back,
     * but there are scenarios where it would make sense to
     * return a different value for a callback parameters
     */
    open fun visitBoolean(v: Boolean): Boolean = v.apply { println("${recorder.recordingClassName}#$methodName boolean $v") }
    open fun visitChar(v: Char): Char = v.apply { println("${recorder.recordingClassName}#$methodName char $v") }
    open fun visitByte(v: Byte): Byte = v.apply { println("${recorder.recordingClassName}#$methodName byte $v") }
    open fun visitShort(v: Short): Short = v.apply { println("${recorder.recordingClassName}#$methodName short $v") }
    open fun visitInt(v: Int): Int = v.apply { println("${recorder.recordingClassName}#$methodName int $v") }
    open fun visitLong(v: Long): Long = v.apply { println("${recorder.recordingClassName}#$methodName long $v") }
    open fun visitFloat(v: Float): Float = v.apply { println("${recorder.recordingClassName}#$methodName float $v") }
    open fun visitDouble(v: Double): Double = v.apply { println("${recorder.recordingClassName}#$methodName double $v") }
    open fun visitObject(v: Any?): Any? = v.apply { println("${recorder.recordingClassName}#$methodName object $v") }

    /**
     * An additional callback to notify all method call parameters were reported
     */
    open fun visitParametersComplete()  {
        println("${recorder.recordingClassName}#$methodName parameters visited")
    }

    /**
     * Writes method completed successfully, assuming the
     * method result was send via the last call with a `visit*` method.
     *
     * The write must not be called if the method result is [Void]
     */
    open fun commitWithResult() {
        println("${recorder.recordingClassName}#$methodName commitWithResult")
    }

    /**
     * Writes method completed with an exception, sending the
     * exception as the method parameter
     */
    open fun commitWithException(exception: Throwable) {
        println("${recorder.recordingClassName}#$methodName commitWithException: $exception")
    }
}

data class MPlayRecorder(
    val recordingClassName: String,
    val configClassName: String,
    val configClasspath: List<URL>,
) {
    init {
        println("MPlayRecorder[$recordingClassName] created")
    }

    /**
     * Used the [InterceptMethodTask.methodName] and [InterceptMethodTask.jvmMethodDescriptor]
     */
    fun onMethodEnter(methodName: String, jvmMethodDescriptor: String) : MPlayMethodCallRecorder {
        println("MPlayRecorder[$recordingClassName] on method: $methodName $jvmMethodDescriptor")
        return MPlayMethodCallRecorder(this, methodName, jvmMethodDescriptor)
    }

    companion object {
        /**
         * This method is executed in bytecode
         */
        @JvmStatic
        fun getInstance(
            recordingClassName: String,
            configClassName: String,
            /**
             * classpath separated with [File.separator]
             */
            configClasspath: String,
        ): MPlayRecorder {
            //we may do caching here if needed
            return MPlayRecorder(
                recordingClassName,
                configClassName,
                configClasspath.split(File.separator).map { File(it).toURI().toURL() })
        }
    }
}
